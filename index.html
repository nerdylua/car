<head>
    <title>3D Car Driving Game</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸš—</text></svg>">
</head>
<style>
    body { 
        margin: 0; 
        overflow: hidden; 
        font-family: 'Arial', sans-serif;
    }
    canvas { display: block; }
    #controls {
        position: fixed;
        bottom: 20px;
        width: 100%;
        display: flex;
        justify-content: center;
        gap: 40px;
        user-select: none; 
        -webkit-user-select: none; 
        -ms-user-select: none;
    }
    .control-group { 
        display: flex; 
        flex-direction: column; 
        align-items: center; 
    }
    .control-group:first-child,
    .control-group:last-child {
        margin-top: 20px;
    }
    .control-row { display: flex; }
    button {
        font-size: 24px; 
        padding: 15px 20px; 
        margin: 5px;
        touch-action: manipulation; 
        background-color: rgba(40, 40, 40, 0.7); 
        color: white;
        border: none; 
        border-radius: 50%;
        width: 70px;
        height: 70px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        transition: all 0.2s ease;
        backdrop-filter: blur(5px);
    }
    button:active { 
        background-color: rgba(80, 80, 80, 0.8); 
        transform: scale(0.95);
    }
    #info {
        position: fixed; 
        top: 10px; 
        left: 10px; 
        color: white; 
        font-family: 'Arial', sans-serif;
        background-color: rgba(0, 0, 0, 0.5); 
        padding: 8px 12px; 
        border-radius: 20px;
        backdrop-filter: blur(5px);
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    #dashboard {
        position: fixed;
        top: 30px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(20, 20, 20, 0.7);
        color: white;
        padding: 10px 20px;
        border-radius: 30px;
        display: flex;
        align-items: center;
        backdrop-filter: blur(5px);
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        z-index: 100;
    }
    #speedometer {
        font-size: 24px;
        font-weight: bold;
        margin-right: 15px;
    }
    #speed-bar {
        height: 6px;
        width: 100px;
        background-color: #333;
        border-radius: 3px;
        overflow: hidden;
    }
    #speed-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #4CAF50, #FFEB3B, #FF5722);
        transition: width 0.2s;
    }
    #time-toggle {
        position: fixed;
        top: 10px;
        right: 10px;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        cursor: pointer;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        backdrop-filter: blur(5px);
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
    }
    #time-toggle:hover {
        background-color: rgba(0, 0, 0, 0.7);
        transform: scale(1.1);
    }
    #time-toggle svg {
        width: 24px;
        height: 24px;
        fill: currentColor;
    }
</style>
<div id="info">Use Arrow Keys/WASD or On-Screen Buttons</div>
<div id="dashboard">
    <div id="speedometer">0 km/h</div>
    <div id="speed-bar"><div id="speed-fill"></div></div>
</div>
<button id="time-toggle">
    <svg id="moon-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/>
    </svg>
    <svg id="sun-icon" style="display: none;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="4"/>
        <path d="M12 2v2"/>
        <path d="M12 20v2"/>
        <path d="m4.93 4.93 1.41 1.41"/>
        <path d="m17.66 17.66 1.41 1.41"/>
        <path d="M2 12h2"/>
        <path d="M20 12h2"/>
        <path d="m6.34 17.66-1.41 1.41"/>
        <path d="m19.07 4.93-1.41 1.41"/>
    </svg>
</button>
<div id="controls">
    <div class="control-group"> 
        <div class="control-row"><button id="leftBtn">â—€</button></div>
    </div>
    <div class="control-group"> 
        <div class="control-row"><button id="accelBtn">â–²</button></div>
        <div class="control-row"><button id="brakeBtn">â–¼</button></div>
    </div>
    <div class="control-group"> 
        <div class="control-row"><button id="rightBtn">â–¶</button></div>
    </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script type="module">
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 90, 380);
    let isDaytime = true;
    const DAY_SKY_COLOR = 0x87CEEB;
    const NIGHT_SKY_COLOR = 0x0a1a2a;
    const DAY_FOG_COLOR = 0x87CEEB;
    const NIGHT_FOG_COLOR = 0x0a1a2a;
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.65);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.85);
    directionalLight.position.set(70, 100, 40);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 500;
    directionalLight.shadow.camera.left = -150;
    directionalLight.shadow.camera.right = 150;
    directionalLight.shadow.camera.top = 150;
    directionalLight.shadow.camera.bottom = -150;
    directionalLight.shadow.bias = -0.001;
    scene.add(directionalLight);
    const fillLight = new THREE.DirectionalLight(0xffffee, 0.25);
    fillLight.position.set(-50, 40, -20);
    scene.add(fillLight);
    const skyDome = new THREE.Mesh(
        new THREE.SphereGeometry(500, 32, 32),
        new THREE.ShaderMaterial({
            uniforms: {
                topColor: { value: new THREE.Color(0x0077ff) },
                bottomColor: { value: new THREE.Color(0xffffff) },
                offset: { value: 33 },
                exponent: { value: 0.6 }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                }
            `,
            side: THREE.BackSide
        })
    );
    scene.add(skyDome);
    const groundSize = 600;
    const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 32, 32);
    for (let i = 0; i < groundGeometry.vertices?.length; i++) {
        const vertex = groundGeometry.vertices?.[i];
        if (vertex && Math.abs(vertex.x) > roadWidth * 0.7) {
            vertex.z = Math.sin(vertex.x * 0.05) * Math.sin(vertex.y * 0.05) * 1.5;
        }
    }
    if (groundGeometry.vertices) groundGeometry.computeVertexNormals();
    const roadWidth = 11;
    const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x3f9e4d, 
        roughness: 0.9,
        metalness: 0.1,
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);
    const roadGeometry = new THREE.PlaneGeometry(roadWidth, groundSize, 1, 100);
    const roadMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x444444, 
        roughness: 0.85,
        metalness: 0.2,
    });
    const road = new THREE.Mesh(roadGeometry, roadMaterial);
    road.rotation.x = -Math.PI / 2;
    road.position.y = 0.01;
    road.receiveShadow = true;
    scene.add(road);
    const markingMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xffffff, 
        roughness: 0.8,
        emissive: 0xffffff,
        emissiveIntensity: 0.1
    });
    const markingGeom = new THREE.PlaneGeometry(0.4, 4);
    for (let i = -groundSize/2 + 5; i < groundSize/2; i += 10) {
        const marking = new THREE.Mesh(markingGeom, markingMaterial);
        marking.rotation.x = -Math.PI / 2; 
        marking.position.set(0, 0.02, i); 
        marking.receiveShadow = true; 
        scene.add(marking);
    }
    const edgeGeom = new THREE.PlaneGeometry(0.3, groundSize);
    const leftEdge = new THREE.Mesh(edgeGeom, markingMaterial);
    leftEdge.rotation.x = -Math.PI / 2;
    leftEdge.position.set(-roadWidth/2 + 0.15, 0.02, 0);
    scene.add(leftEdge);
    const rightEdge = new THREE.Mesh(edgeGeom, markingMaterial);
    rightEdge.rotation.x = -Math.PI / 2;
    rightEdge.position.set(roadWidth/2 - 0.15, 0.02, 0);
    scene.add(rightEdge);
    
    // Create boundary walls
    const wallMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x8B4513, 
        roughness: 0.3,
        metalness: 0.2,
        transparent: true,
        opacity: 0.6
    });
    
    // North wall (positive Z)
    const northWall = new THREE.Mesh(
        new THREE.BoxGeometry(groundSize, 12, 3),
        wallMaterial
    );
    northWall.position.set(0, 6, groundSize/2 + 1.5);
    northWall.castShadow = true;
    northWall.receiveShadow = true;
    scene.add(northWall);
    
    // South wall (negative Z)
    const southWall = new THREE.Mesh(
        new THREE.BoxGeometry(groundSize, 12, 3),
        wallMaterial
    );
    southWall.position.set(0, 6, -groundSize/2 - 1.5);
    southWall.castShadow = true;
    southWall.receiveShadow = true;
    scene.add(southWall);
    
    // East wall (positive X)
    const eastWall = new THREE.Mesh(
        new THREE.BoxGeometry(3, 12, groundSize),
        wallMaterial
    );
    eastWall.position.set(groundSize/2 + 1.5, 6, 0);
    eastWall.castShadow = true;
    eastWall.receiveShadow = true;
    scene.add(eastWall);
    
    // West wall (negative X)
    const westWall = new THREE.Mesh(
        new THREE.BoxGeometry(3, 12, groundSize),
        wallMaterial
    );
    westWall.position.set(-groundSize/2 - 1.5, 6, 0);
    westWall.castShadow = true;
    westWall.receiveShadow = true;
    scene.add(westWall);
    const car = new THREE.Group();
    car.position.set(0, 0.5, 5);
    scene.add(car);
    const carBodyWidth = 2.0;
    const carBodyHeight = 1.0;
    const carBodyLength = 4.0;
    const carBodyMaterial = new THREE.MeshStandardMaterial({
        color: 0xe51e1e,
        roughness: 0.2,
        metalness: 0.8
    });
    const carBodyGeometry = new THREE.BoxGeometry(carBodyWidth, carBodyHeight, carBodyLength);
    const carBody = new THREE.Mesh(carBodyGeometry, carBodyMaterial);
    carBody.castShadow = true;
    carBody.receiveShadow = true;
    car.add(carBody);
    const carTopWidth = carBodyWidth * 0.85;
    const carTopHeight = carBodyHeight * 0.8;
    const carTopLength = carBodyLength * 0.55;
    const carTopGeometry = new THREE.BoxGeometry(carTopWidth, carTopHeight, carTopLength);
    const carTopMaterial = new THREE.MeshStandardMaterial({
         color: 0xeeeeee,
         roughness: 0.2,
         metalness: 0.6
    });
    const carTop = new THREE.Mesh(carTopGeometry, carTopMaterial);
    carTop.position.y = carBodyHeight / 2 + carTopHeight / 2 - 0.1;
    carTop.position.z = -carBodyLength * 0.1;
    carTop.castShadow = true;
    carBody.add(carTop);
    const windowMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x333333,
        metalness: 0.9,
        roughness: 0.1,
        transparent: true,
        opacity: 0.8,
        envMapIntensity: 1.0
    });
    const windshieldGeom = new THREE.PlaneGeometry(carTopWidth * 0.8, carTopHeight * 0.8);
    const windshield = new THREE.Mesh(windshieldGeom, windowMaterial);
    windshield.position.z = carTopLength/2 * 0.95;
    windshield.position.y = 0.1;
    windshield.rotation.x = Math.PI * 0.06;
    carTop.add(windshield);
    const rearWindshield = new THREE.Mesh(windshieldGeom, windowMaterial);
    rearWindshield.position.z = -carTopLength/2 * 0.95;
    rearWindshield.position.y = 0.1;
    rearWindshield.rotation.x = -Math.PI * 0.06;
    carTop.add(rearWindshield);
    const sideWindowGeom = new THREE.PlaneGeometry(carTopLength * 0.8, carTopHeight * 0.6);
    const leftWindow = new THREE.Mesh(sideWindowGeom, windowMaterial);
    leftWindow.position.x = -carTopWidth/2 - 0.01;
    leftWindow.position.y = 0;
    leftWindow.rotation.y = Math.PI/2;
    carTop.add(leftWindow);
    const rightWindow = new THREE.Mesh(sideWindowGeom, windowMaterial);
    rightWindow.position.x = carTopWidth/2 + 0.01;
    rightWindow.position.y = 0;
    rightWindow.rotation.y = -Math.PI/2;
    carTop.add(rightWindow);
    const wheelRadius = 0.4;
    const wheelWidth = 0.3;
    const wheelMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x222222, 
        roughness: 0.6,
        metalness: 0.2 
    });
    const wheelGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelWidth, 24);
    wheelGeometry.rotateZ(Math.PI / 2);
    const rimMaterial = new THREE.MeshStandardMaterial({
        color: 0xdddddd,
        roughness: 0.2,
        metalness: 0.8
    });
    const wheelPositions = [
        { x: carBodyWidth / 2 + wheelWidth/2, y: -carBodyHeight / 2 + wheelRadius , z: carBodyLength / 2 - wheelRadius * 1.3 },
        { x: -carBodyWidth / 2 - wheelWidth/2, y: -carBodyHeight / 2 + wheelRadius , z: carBodyLength / 2 - wheelRadius * 1.3 },
        { x: carBodyWidth / 2 + wheelWidth/2, y: -carBodyHeight / 2 + wheelRadius , z: -carBodyLength / 2 + wheelRadius * 1.3 },
        { x: -carBodyWidth / 2 - wheelWidth/2, y: -carBodyHeight / 2 + wheelRadius , z: -carBodyLength / 2 + wheelRadius * 1.3 }
    ];
    const wheels = [];
    const wheelRims = [];
    wheelPositions.forEach(pos => {
        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        wheel.position.set(pos.x, pos.y, pos.z);
        wheel.castShadow = true;
        const rimGeometry = new THREE.CylinderGeometry(wheelRadius * 0.6, wheelRadius * 0.6, wheelWidth + 0.01, 8);
        rimGeometry.rotateZ(Math.PI / 2);
        const rim = new THREE.Mesh(rimGeometry, rimMaterial);
        const spokeGroup = new THREE.Group();
        const spokeGeometry = new THREE.BoxGeometry(wheelWidth + 0.02, wheelRadius * 0.1, wheelRadius * 1.2);
        for (let i = 0; i < 5; i++) {
            const spoke = new THREE.Mesh(spokeGeometry, rimMaterial);
            spoke.rotation.z = Math.PI * 2 * (i / 5);
            spokeGroup.add(spoke);
        }
        rim.add(spokeGroup);
        wheel.add(rim);
        wheelRims.push(rim);
        carBody.add(wheel);
        wheels.push(wheel);
    });
    const createLight = (color, width, height, isEmissive = false) => {
        const material = new THREE.MeshStandardMaterial({ 
            color: color,
            roughness: 0.5,
            metalness: 0.2,
            emissive: isEmissive ? color : 0x000000,
            emissiveIntensity: isEmissive ? 0.5 : 0
        });
        return new THREE.Mesh(new THREE.PlaneGeometry(width, height), material);
    };
    const headlightL = createLight(0xffffee, 0.35, 0.2, true);
    headlightL.position.set(-carBodyWidth * 0.3, carBodyHeight * 0.1, carBodyLength / 2 + 0.01);
    carBody.add(headlightL);
    const headlightR = createLight(0xffffee, 0.35, 0.2, true);
    headlightR.position.set(carBodyWidth * 0.3, carBodyHeight * 0.1, carBodyLength / 2 + 0.01);
    carBody.add(headlightR);
    const taillightL = createLight(0xff4444, 0.3, 0.18, true);
    taillightL.position.set(-carBodyWidth * 0.35, carBodyHeight * 0.1, -carBodyLength / 2 - 0.01);
    taillightL.rotation.y = Math.PI;
    carBody.add(taillightL);
    const taillightR = createLight(0xff4444, 0.3, 0.18, true);
    taillightR.position.set(carBodyWidth * 0.35, carBodyHeight * 0.1, -carBodyLength / 2 - 0.01);
    taillightR.rotation.y = Math.PI;
    carBody.add(taillightR);
    const createHeadlightBeam = () => {
        const beamGeometry = new THREE.CylinderGeometry(0.1, 1.5, 10, 12);
        beamGeometry.rotateX(Math.PI/2);
        const beamMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffaa,
            transparent: true,
            opacity: 0.15,
            side: THREE.DoubleSide
        });
        return new THREE.Mesh(beamGeometry, beamMaterial);
    };
    const leftBeam = createHeadlightBeam();
    leftBeam.position.set(-carBodyWidth * 0.3, carBodyHeight * 0.1, carBodyLength / 2 + 5);
    carBody.add(leftBeam);
    const rightBeam = createHeadlightBeam();
    rightBeam.position.set(carBodyWidth * 0.3, carBodyHeight * 0.1, carBodyLength / 2 + 5);
    carBody.add(rightBeam);
    const leftHeadlightLight = new THREE.PointLight(0xffffee, 0.7, 20);
    leftHeadlightLight.position.set(-carBodyWidth * 0.3, carBodyHeight * 0.1, carBodyLength / 2);
    leftHeadlightLight.visible = false;
    carBody.add(leftHeadlightLight);
    const rightHeadlightLight = new THREE.PointLight(0xffffee, 0.7, 20);
    rightHeadlightLight.position.set(carBodyWidth * 0.3, carBodyHeight * 0.1, carBodyLength / 2);
    rightHeadlightLight.visible = false;
    carBody.add(rightHeadlightLight);
    const plateGeometry = new THREE.PlaneGeometry(1.2, 0.4);
    const plateMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xeeeeee, 
        roughness: 0.9,
        metalness: 0
    });
    const plate = new THREE.Mesh(plateGeometry, plateMaterial);
    plate.position.set(0, -0.2, -carBodyLength/2 - 0.01);
    plate.rotation.y = Math.PI;
    carBody.add(plate);
    const createBumper = (position) => {
        const bumperGeom = new THREE.BoxGeometry(carBodyWidth * 1.02, carBodyHeight * 0.2, 0.3);
        const bumperMat = new THREE.MeshStandardMaterial({
            color: 0xdddddd,
            roughness: 0.4,
            metalness: 0.6
        });
        const bumper = new THREE.Mesh(bumperGeom, bumperMat);
        bumper.position.y = -carBodyHeight * 0.3;
        bumper.position.z = position;
        bumper.castShadow = true;
        return bumper;
    };
    carBody.add(createBumper(carBodyLength/2));
    carBody.add(createBumper(-carBodyLength/2));
    const createTreeAt = (x, z, scale = 1) => {
        const tree = new THREE.Group();
        const trunkHeight = (Math.random() * 4 + 3) * scale;
        const trunkRadius = (0.25 + Math.random() * 0.1) * scale;
        const trunkGeo = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, trunkHeight, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x8B4513, 
            roughness: 0.9,
            metalness: 0,
        });
        const trunk = new THREE.Mesh(trunkGeo, trunkMaterial);
        trunk.position.y = trunkHeight / 2;
        trunk.castShadow = true;
        tree.add(trunk);
        const createLeafCluster = (y, size) => {
            const leafColor = new THREE.Color(0x2E8B57).lerp(
                new THREE.Color(0x90EE90), 
                Math.random() * 0.3
            );
            const leavesGeo = new THREE.SphereGeometry(size, 8, 6);
            const leavesMat = new THREE.MeshStandardMaterial({ 
                color: leafColor, 
                roughness: 0.8,
                metalness: 0
            });
            const leaves = new THREE.Mesh(leavesGeo, leavesMat);
            leaves.position.y = y;
            leaves.position.x = (Math.random() - 0.5) * size * 0.5;
            leaves.position.z = (Math.random() - 0.5) * size * 0.5;
            leaves.castShadow = true;
            leaves.receiveShadow = true;
            return leaves;
        };
        const baseLeafSize = (Math.random() * 1.5 + 1.5) * scale;
        const baseY = trunkHeight * 0.8;
        tree.add(createLeafCluster(baseY, baseLeafSize));
        tree.add(createLeafCluster(baseY + baseLeafSize * 0.4, baseLeafSize * 0.8));
        tree.add(createLeafCluster(baseY - baseLeafSize * 0.3, baseLeafSize * 0.9));
        tree.add(createLeafCluster(baseY + baseLeafSize * 0.7, baseLeafSize * 0.6));
        tree.position.set(x, 0, z);
        tree.rotation.y = Math.random() * Math.PI * 2;
        scene.add(tree);
        return tree;
    };
    for (let i = 0; i < 70; i++) {
        let treeX, treeZ;
        do { 
            treeX = (Math.random() - 0.5) * (groundSize - 20); 
            treeZ = (Math.random() - 0.5) * (groundSize - 20); 
        } while (Math.abs(treeX) < roadWidth + 5);
        const treeScale = 0.8 + Math.random() * 0.4;
        createTreeAt(treeX, treeZ, treeScale);
    }
    for (let i = 0; i < 5; i++) {
        const clumpCenterX = (Math.random() - 0.5) * (groundSize - 100);
        const clumpCenterZ = (Math.random() - 0.5) * (groundSize - 100);
        if (Math.abs(clumpCenterX) < roadWidth + 40) continue;
        const clumpSize = Math.random() * 20 + 10;
        for (let j = 0; j < 8; j++) {
            const treeX = clumpCenterX + (Math.random() - 0.5) * clumpSize;
            const treeZ = clumpCenterZ + (Math.random() - 0.5) * clumpSize;
            const treeScale = 0.7 + Math.random() * 0.6;
            createTreeAt(treeX, treeZ, treeScale);
        }
    }
    const createRock = (x, z, scale) => {
        const rockGeometry = new THREE.DodecahedronGeometry(1, 1);
        const vertices = rockGeometry.vertices || [];
        for (let i = 0; i < vertices.length; i++) {
            vertices[i].x += (Math.random() - 0.5) * 0.2;
            vertices[i].y += (Math.random() - 0.5) * 0.2;
            vertices[i].z += (Math.random() - 0.5) * 0.2;
        }
        const colorVariation = Math.random() * 0.2;
        const rockMaterial = new THREE.MeshStandardMaterial({ 
            color: new THREE.Color(0.5 + colorVariation, 0.5 + colorVariation, 0.5 + colorVariation), 
            roughness: 0.9,
            metalness: 0.1
        });
        const rock = new THREE.Mesh(rockGeometry, rockMaterial);
        rock.scale.set(
            scale, 
            scale * (0.6 + Math.random() * 0.6),
            scale * (0.7 + Math.random() * 0.5)
        );
        rock.rotation.set(
            Math.random() * Math.PI, 
            Math.random() * Math.PI, 
            Math.random() * Math.PI
        );
        rock.position.set(x, scale * 0.5, z);
        rock.castShadow = true;
        rock.receiveShadow = true;
        scene.add(rock);
    };
    for (let i = 0; i < 35; i++) {
        let rockX, rockZ;
        do { 
            rockX = (Math.random() - 0.5) * (groundSize - 20); 
            rockZ = (Math.random() - 0.5) * (groundSize - 20); 
        } while (Math.abs(rockX) < roadWidth + 2);
        const rockScale = Math.random() * 0.7 + 0.5;
        createRock(rockX, rockZ, rockScale);
    }
    for (let i = 0; i < 3; i++) {
        const formationX = (Math.random() - 0.5) * (groundSize - 60);
        const formationZ = (Math.random() - 0.5) * (groundSize - 60);
        if (Math.abs(formationX) < roadWidth + 20) continue;
        for (let j = 0; j < 5; j++) {
            const rockX = formationX + (Math.random() - 0.5) * 8;
            const rockZ = formationZ + (Math.random() - 0.5) * 8;
            const rockScale = Math.random() * 1.2 + 0.8;
            createRock(rockX, rockZ, rockScale);
        }
    }
    const createBush = (x, z, scale, color = 0x3CB371) => {
        const bushGeometry = new THREE.SphereGeometry(0.9, 8, 6);
        const colorAdjustment = (Math.random() - 0.5) * 0.2;
        const baseColor = new THREE.Color(color);
        baseColor.r += colorAdjustment;
        baseColor.g += colorAdjustment;
        baseColor.b += colorAdjustment;
        const bushMaterial = new THREE.MeshStandardMaterial({ 
            color: baseColor, 
            roughness: 0.8,
            metalness: 0
        });
        const bush = new THREE.Group();
        const mainBush = new THREE.Mesh(bushGeometry, bushMaterial);
        bush.add(mainBush);
        for (let i = 0; i < Math.floor(Math.random() * 2) + 2; i++) {
            const smallBush = new THREE.Mesh(bushGeometry, bushMaterial);
            smallBush.scale.set(0.6, 0.6, 0.6);
            smallBush.position.set(
                (Math.random() - 0.5) * 0.8,
                (Math.random() - 0.5) * 0.5 + 0.1,
                (Math.random() - 0.5) * 0.8
            );
            bush.add(smallBush);
        }
        bush.scale.set(
            scale, 
            scale * (0.8 + Math.random() * 0.4), 
            scale
        );
        bush.position.set(x, scale * 0.45, z);
        bush.castShadow = true;
        bush.receiveShadow = true;
        scene.add(bush);
    };
    for (let i = 0; i < 60; i++) {
        let bushX, bushZ;
        do { 
            bushX = (Math.random() - 0.5) * (groundSize - 20); 
            bushZ = (Math.random() - 0.5) * (groundSize - 20); 
        } while (Math.abs(bushX) < roadWidth + 3);
        const bushScale = Math.random() * 0.5 + 0.5;
        const bushColor = Math.random() > 0.8 ? 0x9ACD32 : 0x3CB371;
        createBush(bushX, bushZ, bushScale, bushColor);
    }
    for (let i = -groundSize/3; i < groundSize/3; i += 15) {
        if (Math.random() > 0.3) continue;
        const side = Math.random() > 0.5 ? 1 : -1;
        const bushX = side * (roadWidth/2 + 1.5 + Math.random());
        createBush(bushX, i, Math.random() * 0.4 + 0.3);
        if (Math.random() > 0.5) {
            createBush(
                bushX + (Math.random() - 0.5) * 1.5,
                i + (Math.random() - 0.5) * 3,
                Math.random() * 0.3 + 0.2
            );
        }
    }
    const createCloud = (x, y, z, scale) => {
        const cloudGroup = new THREE.Group();
        const cloudMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, 
            transparent: true, 
            opacity: 0.92 
        });
        const mainCloud = new THREE.Mesh(
            new THREE.SphereGeometry(6 * scale, 8, 8), 
            cloudMaterial
        );
        cloudGroup.add(mainCloud);
        const puffCount = Math.floor(Math.random() * 3) + 4;
        for (let j = 0; j < puffCount; j++) {
            const puffScale = Math.random() * 0.6 + 0.4;
            const puff = new THREE.Mesh(
                new THREE.SphereGeometry(5 * scale * puffScale, 7, 7), 
                cloudMaterial
            );
            puff.position.set(
                (Math.random() - 0.5) * 12 * scale,
                (Math.random() - 0.5) * 4 * scale,
                (Math.random() - 0.5) * 10 * scale
            );
            cloudGroup.add(puff);
        }
        cloudGroup.position.set(x, y, z);
        cloudGroup.userData = {
            speed: Math.random() * 0.03 + 0.01,
            originalX: x
        };
        scene.add(cloudGroup);
        return cloudGroup;
    };
    const clouds = [];
    for (let i = 0; i < 20; i++) {
        const x = (Math.random() - 0.5) * (groundSize + 100);
        const y = Math.random() * 40 + 60;
        const z = (Math.random() - 0.5) * (groundSize + 100);
        const scale = Math.random() * 0.5 + 0.7;
        clouds.push(createCloud(x, y, z, scale));
    }
    const createMountain = (x, z, height, radius) => {
        const segments = 24;
        const mountainGeo = new THREE.ConeGeometry(radius, height, segments);
        const vertices = mountainGeo.vertices || [];
        if (vertices && vertices.length > 0) {
            for (let i = 0; i < vertices.length; i++) {
                if (vertices[i].y < height - 0.1) {
                    vertices[i].x += (Math.random() - 0.5) * radius * 0.15;
                    vertices[i].z += (Math.random() - 0.5) * radius * 0.15;
                }
            }
            mountainGeo.computeVertexNormals();
        }
        const colorVariation = Math.random() * 0.15;
        const mountainColor = new THREE.Color(
            0.6 + colorVariation,
            0.6 + colorVariation,
            0.65 + colorVariation
        );
        const mountainMaterial = new THREE.MeshStandardMaterial({ 
            color: mountainColor, 
            roughness: 0.9,
            metalness: 0.1
        });
        const mountain = new THREE.Mesh(mountainGeo, mountainMaterial);
        mountain.position.set(x, height / 2 - 0.1, z);
        mountain.castShadow = true;
        mountain.receiveShadow = true;
        scene.add(mountain);
        if (height > 100) {
            const snowCapGeo = new THREE.ConeGeometry(radius * 0.3, height * 0.2, segments);
            const snowMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf0f0f0, 
                roughness: 0.8,
                metalness: 0.1
            });
            const snowCap = new THREE.Mesh(snowCapGeo, snowMaterial);
            snowCap.position.y = height / 2 - height * 0.1;
            mountain.add(snowCap);
        }
        return mountain;
    };
    for (let i = 0; i < 12; i++) {
        const angle = Math.PI * 2 * (i / 12);
        const distance = Math.random() * 180 + groundSize * 0.55;
        const x = Math.cos(angle) * distance;
        const z = Math.sin(angle) * distance;
        const height = Math.random() * 120 + 60;
        const radius = Math.random() * 50 + 30;
        createMountain(x, z, height, radius);
    }
    for (let i = 0; i < 6; i++) {
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * 100 + groundSize * 0.3;
        const x = Math.cos(angle) * distance;
        const z = Math.sin(angle) * distance;
        if (Math.abs(x) < roadWidth * 2) continue;
        const height = Math.random() * 40 + 20;
        const radius = Math.random() * 30 + 15;
        createMountain(x, z, height, radius);
    }
    const train = new THREE.Group();
    scene.add(train);
    const createLocomotive = () => {
        const loco = new THREE.Group();
        const bodyMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2c3e50, 
            roughness: 0.6, 
            metalness: 0.4 
        });
        const bodyGeom = new THREE.BoxGeometry(3.2, 3.2, 6);
        const body = new THREE.Mesh(bodyGeom, bodyMaterial);
        body.castShadow = true;
        body.receiveShadow = true;
        loco.add(body);
        const cabinMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x34495e, 
            roughness: 0.7, 
            metalness: 0.3 
        });
        const cabinGeom = new THREE.BoxGeometry(3, 1.8, 3);
        const cabin = new THREE.Mesh(cabinGeom, cabinMaterial);
        cabin.position.y = 0.6;
        cabin.position.z = -1.2;
        cabin.castShadow = true;
        body.add(cabin);
        const windowMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xadd8e6,
            metalness: 0.9,
            roughness: 0.1,
            transparent: true,
            opacity: 0.8
        });
        const frontWindowGeom = new THREE.PlaneGeometry(1, 0.8);
        const frontWindow = new THREE.Mesh(frontWindowGeom, windowMaterial);
        frontWindow.position.set(0, 0, 1.51);
        cabin.add(frontWindow);
        const stackGeom = new THREE.CylinderGeometry(0.4, 0.5, 1.2, 8);
        const stackMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x1a1a1a, 
            roughness: 0.8 
        });
        const smokestack = new THREE.Mesh(stackGeom, stackMaterial);
        smokestack.position.set(0, 2, 1.8);
        body.add(smokestack);
        const wheelMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x111111, 
            roughness: 0.7, 
            metalness: 0.2 
        });
        for (let i = -1.5; i <= 1.5; i += 1.5) {
            for (let j = -1; j <= 1; j++) {
                const wheelGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 16);
                wheelGeom.rotateX(Math.PI/2);
                const wheel = new THREE.Mesh(wheelGeom, wheelMaterial);
                wheel.position.set(i, -1.6, j * 2);
                body.add(wheel);
                const rimGeom = new THREE.CylinderGeometry(0.3, 0.3, 0.32, 8);
                rimGeom.rotateX(Math.PI/2);
                const rim = new THREE.Mesh(rimGeom, new THREE.MeshStandardMaterial({ 
                    color: 0x777777, 
                    roughness: 0.5, 
                    metalness: 0.5 
                }));
                wheel.add(rim);
            }
        }
        return loco;
    };
    const locomotive = createLocomotive();
    locomotive.position.z = 5;
    train.add(locomotive);
    const createCarriage = (color) => {
        const carriage = new THREE.Group();
        const carriageMaterial = new THREE.MeshStandardMaterial({ 
            color: color, 
            roughness: 0.6, 
            metalness: 0.3 
        });
        const carriageGeom = new THREE.BoxGeometry(3, 2.5, 8);
        const carriageBody = new THREE.Mesh(carriageGeom, carriageMaterial);
        carriageBody.castShadow = true;
        carriageBody.receiveShadow = true;
        carriage.add(carriageBody);
        const windowMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xadd8e6,
            metalness: 0.9,
            roughness: 0.1,
            transparent: true,
            opacity: 0.7
        });
        for (let i = -2.5; i <= 2.5; i += 1.25) {
            const windowGeom = new THREE.PlaneGeometry(0.8, 1);
            const leftWindow = new THREE.Mesh(windowGeom, windowMaterial);
            leftWindow.position.set(-1.51, 0.2, i);
            leftWindow.rotation.y = Math.PI/2;
            carriageBody.add(leftWindow);
            const rightWindow = new THREE.Mesh(windowGeom, windowMaterial);
            rightWindow.position.set(1.51, 0.2, i);
            rightWindow.rotation.y = -Math.PI/2;
            carriageBody.add(rightWindow);
        }
        const wheelMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x111111, 
            roughness: 0.7, 
            metalness: 0.2 
        });
        for (let i = -1.25; i <= 1.25; i += 2.5) {
            for (let j = -2.5; j <= 2.5; j += 5) {
                const wheelGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 12);
                wheelGeom.rotateX(Math.PI/2);
                const wheel = new THREE.Mesh(wheelGeom, wheelMaterial);
                wheel.position.set(i, -1.25, j);
                carriageBody.add(wheel);
            }
        }
        return carriage;
    };
    const carriageColors = [0x3498db, 0x2ecc71, 0xe74c3c];
    for (let i = 0; i < 3; i++) {
        const carriage = createCarriage(carriageColors[i % carriageColors.length]);
        carriage.position.z = -10 - i * 10;
        train.add(carriage);
    }
    const createTrack = (radius) => {
        const track = new THREE.Group();
        const outerRailGeo = new THREE.TorusGeometry(radius, 0.15, 16, 100);
        const railMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x555555, 
            roughness: 0.7,
            metalness: 0.3
        });
        const outerRail = new THREE.Mesh(outerRailGeo, railMaterial);
        track.add(outerRail);
        const innerRailGeo = new THREE.TorusGeometry(radius - 2, 0.15, 16, 100);
        const innerRail = new THREE.Mesh(innerRailGeo, railMaterial);
        track.add(innerRail);
        const tieGeom = new THREE.BoxGeometry(3, 0.2, 0.5);
        const tieMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x5D4037, 
            roughness: 0.9,
            metalness: 0
        });
        for (let i = 0; i < 100; i++) {
            const angle = Math.PI * 2 * (i / 100);
            const tie = new THREE.Mesh(tieGeom, tieMaterial);
            tie.position.x = Math.cos(angle) * radius;
            tie.position.z = Math.sin(angle) * radius;
            tie.rotation.y = angle + Math.PI/2;
            tie.position.y = -0.1;
            track.add(tie);
        }
        track.rotation.x = Math.PI/2;
        track.position.y = 0.05;
        track.receiveShadow = true;
        return track;
    };
    const trackRadius = 190;
    const trainSpeed = 0.003;
    let trainAngle = 0;
    scene.add(createTrack(trackRadius));
    const sunMoonGeometry = new THREE.SphereGeometry(15, 16, 16);
    const sunMaterial = new THREE.MeshBasicMaterial({
        color: 0xffff80,
        transparent: true,
        opacity: 0.9
    });
    const moonMaterial = new THREE.MeshBasicMaterial({
        color: 0xdddddd,
        transparent: true,
        opacity: 0.9
    });
    const sunMoon = new THREE.Mesh(sunMoonGeometry, sunMaterial);
    sunMoon.position.set(300, 100, -200);
    scene.add(sunMoon);
    const lakeGeometry = new THREE.CircleGeometry(40, 32);
    const lakeMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x0077be,
        roughness: 0.1,
        metalness: 0.8,
        opacity: 0.9,
        transparent: true
    });
    const lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
    lake.rotation.x = -Math.PI/2;
    lake.position.set(-80, 0.05, -100);
    scene.add(lake);
    for (let i = 0; i < 12; i++) {
        const angle = Math.PI * 2 * (i / 12);
        const x = lake.position.x + Math.cos(angle) * 42;
        const z = lake.position.z + Math.sin(angle) * 42;
        createRock(x, z, Math.random() * 0.5 + 0.4);
    }
    const dustParticleCount = 30;
    const dustParticles = new THREE.BufferGeometry();
    const dustPositions = new Float32Array(dustParticleCount * 3);
    const dustSizes = new Float32Array(dustParticleCount);
    for (let i = 0; i < dustParticleCount; i++) {
        dustPositions[i * 3] = 0;
        dustPositions[i * 3 + 1] = 0;
        dustPositions[i * 3 + 2] = 0;
        dustSizes[i] = 0;
    }
    dustParticles.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
    dustParticles.setAttribute('size', new THREE.BufferAttribute(dustSizes, 1));
    const dustMaterial = new THREE.PointsMaterial({
        color: 0xD2B48C,
        size: 0.5,
        transparent: true,
        opacity: 0.6,
        sizeAttenuation: true
    });
    const dustSystem = new THREE.Points(dustParticles, dustMaterial);
    scene.add(dustSystem);
    const activeParticles = [];
    const controls = { accelerate: false, brake: false, steerLeft: false, steerRight: false };
    let speed = 0;
    const maxSpeed = 2.13; 
    const maxReverseSpeed = 0.35;
    const acceleration = 0.0173; 
    const brakingForce = 0.045;
    const reverseAcceleration = 0.015;
    const friction = 0.98;
    const steeringSpeed = 0.035;
    const wheelRotationSpeed = 0.1;
    let isTransitioning = false;
    const toggleDayNight = () => {
        if (isTransitioning) return;
        isTransitioning = true;
        const targetSkyColor = isDaytime ? NIGHT_SKY_COLOR : DAY_SKY_COLOR;
        const targetFogColor = isDaytime ? NIGHT_FOG_COLOR : DAY_FOG_COLOR;
        const startSkyColor = isDaytime ? DAY_SKY_COLOR : NIGHT_SKY_COLOR;
        const startFogColor = isDaytime ? DAY_FOG_COLOR : NIGHT_FOG_COLOR;
        leftHeadlightLight.visible = isDaytime;
        rightHeadlightLight.visible = isDaytime;
        leftBeam.visible = isDaytime;
        rightBeam.visible = isDaytime;
        const targetAmbientIntensity = isDaytime ? 0.25 : 0.65;
        const startAmbientIntensity = isDaytime ? 0.65 : 0.25;
        const targetDirectionalIntensity = isDaytime ? 0.2 : 0.85;
        const startDirectionalIntensity = isDaytime ? 0.85 : 0.2;
        sunMoon.material = isDaytime ? moonMaterial : sunMaterial;
        
        const startTime = Date.now();
        const duration = 2000;
        function updateTransition() {
            const currentTime = Date.now();
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const currentSkyColor = new THREE.Color();
            currentSkyColor.r = startSkyColor >> 16 & 255 / 255 + (targetSkyColor >> 16 & 255 / 255 - startSkyColor >> 16 & 255 / 255) * progress;
            currentSkyColor.g = startSkyColor >> 8 & 255 / 255 + (targetSkyColor >> 8 & 255 / 255 - startSkyColor >> 8 & 255 / 255) * progress;
            currentSkyColor.b = startSkyColor & 255 / 255 + (targetSkyColor & 255 / 255 - startSkyColor & 255 / 255) * progress;
            const currentFogColor = new THREE.Color();
            currentFogColor.r = startFogColor >> 16 & 255 / 255 + (targetFogColor >> 16 & 255 / 255 - startFogColor >> 16 & 255 / 255) * progress;
            currentFogColor.g = startFogColor >> 8 & 255 / 255 + (targetFogColor >> 8 & 255 / 255 - startFogColor >> 8 & 255 / 255) * progress;
            currentFogColor.b = startFogColor & 255 / 255 + (targetFogColor & 255 / 255 - startFogColor & 255 / 255) * progress;
            scene.background = currentSkyColor;
            scene.fog.color = currentFogColor;
            ambientLight.intensity = startAmbientIntensity + (targetAmbientIntensity - startAmbientIntensity) * progress;
            directionalLight.intensity = startDirectionalIntensity + (targetDirectionalIntensity - startDirectionalIntensity) * progress;
            if (progress < 1) {
                requestAnimationFrame(updateTransition);
            } else {
                isDaytime = !isDaytime;
                isTransitioning = false;
                
                // Toggle icon visibility after the transition is complete
                const sunIcon = document.getElementById('sun-icon');
                const moonIcon = document.getElementById('moon-icon');
                if (isDaytime) {
                    // Now daytime, show moon icon (will switch to night)
                    sunIcon.style.display = 'none';
                    moonIcon.style.display = 'block';
                } else {
                    // Now nighttime, show sun icon (will switch to day)
                    sunIcon.style.display = 'block';
                    moonIcon.style.display = 'none';
                }
            }
        }
        updateTransition();
    };
    // Set initial icon state
    const sunIcon = document.getElementById('sun-icon');
    const moonIcon = document.getElementById('moon-icon');
    if (isDaytime) {
        // Currently daytime, show moon icon (will switch to night)
        sunIcon.style.display = 'none';
        moonIcon.style.display = 'block';
    } else {
        // Currently nighttime, show sun icon (will switch to day)
        sunIcon.style.display = 'block';
        moonIcon.style.display = 'none';
    }
    
    document.getElementById('time-toggle').addEventListener('click', toggleDayNight);
    document.addEventListener('keydown', (event) => {
         switch(event.key.toLowerCase()) {
             case 'arrowup': case 'w': controls.accelerate = true; break;
             case 'arrowdown': case 's': controls.brake = true; break;
             case 'arrowleft': case 'a': controls.steerLeft = true; break;
             case 'arrowright': case 'd': controls.steerRight = true; break;
         }
     });
     document.addEventListener('keyup', (event) => {
         switch(event.key.toLowerCase()) {
             case 'arrowup': case 'w': controls.accelerate = false; break;
             case 'arrowdown': case 's': controls.brake = false; break;
             case 'arrowleft': case 'a': controls.steerLeft = false; break;
             case 'arrowright': case 'd': controls.steerRight = false; break;
         }
     });
    const accelBtn = document.getElementById('accelBtn');
    const brakeBtn = document.getElementById('brakeBtn');
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    // Touch events for mobile devices
    accelBtn.addEventListener('touchstart', (e) => { e.preventDefault(); controls.accelerate = true; }, { passive: false });
    accelBtn.addEventListener('touchend', (e) => { e.preventDefault(); controls.accelerate = false; });
    brakeBtn.addEventListener('touchstart', (e) => { e.preventDefault(); controls.brake = true; }, { passive: false });
    brakeBtn.addEventListener('touchend', (e) => { e.preventDefault(); controls.brake = false; });
    leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); controls.steerLeft = true; }, { passive: false });
    leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); controls.steerLeft = false; });
    rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); controls.steerRight = true; }, { passive: false });
    rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); controls.steerRight = false; });
    
    // Mouse events for desktop devices
    accelBtn.addEventListener('mousedown', (e) => { e.preventDefault(); controls.accelerate = true; });
    accelBtn.addEventListener('mouseup', (e) => { e.preventDefault(); controls.accelerate = false; });
    accelBtn.addEventListener('mouseleave', (e) => { e.preventDefault(); controls.accelerate = false; });
    brakeBtn.addEventListener('mousedown', (e) => { e.preventDefault(); controls.brake = true; });
    brakeBtn.addEventListener('mouseup', (e) => { e.preventDefault(); controls.brake = false; });
    brakeBtn.addEventListener('mouseleave', (e) => { e.preventDefault(); controls.brake = false; });
    leftBtn.addEventListener('mousedown', (e) => { e.preventDefault(); controls.steerLeft = true; });
    leftBtn.addEventListener('mouseup', (e) => { e.preventDefault(); controls.steerLeft = false; });
    leftBtn.addEventListener('mouseleave', (e) => { e.preventDefault(); controls.steerLeft = false; });
    rightBtn.addEventListener('mousedown', (e) => { e.preventDefault(); controls.steerRight = true; });
    rightBtn.addEventListener('mouseup', (e) => { e.preventDefault(); controls.steerRight = false; });
    rightBtn.addEventListener('mouseleave', (e) => { e.preventDefault(); controls.steerRight = false; });
    
    document.getElementById('controls').addEventListener('touchstart', (e) => { e.preventDefault(); }, { passive: false });
    window.addEventListener('resize', onWindowResize, false);
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    const clock = new THREE.Clock();
    const cameraOffset = new THREE.Vector3(0, 6.5, -13);
    const updateSpeedometer = () => {
        const speedKmh = Math.abs(speed) * 100;
        document.getElementById('speedometer').textContent = `${speedKmh.toFixed(0)} km/h`;
        const speedPercentage = Math.abs(speed) / maxSpeed * 100;
        document.getElementById('speed-fill').style.width = `${speedPercentage}%`;
    };
    const generateDustParticle = () => {
        if (Math.abs(speed) < 0.2) return;
        const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 2,
            0.1,
            -carBodyLength/2 - 0.5
        );
        offset.applyQuaternion(car.quaternion);
        const position = car.position.clone().add(offset);
        activeParticles.push({
            position: position,
            size: Math.random() * 0.6 + 0.3,
            life: 1.0,
            velocity: new THREE.Vector3(
                (Math.random() - 0.5) * 0.03,
                Math.random() * 0.05 + 0.02,
                (Math.random() - 0.5) * 0.03
            )
        });
    };
    const updateDustParticles = (delta) => {
        if (Math.abs(speed) > 0.2 && Math.random() < Math.abs(speed) * 2) {
            generateDustParticle();
        }
        for (let i = 0; i < activeParticles.length; i++) {
            const particle = activeParticles[i];
            particle.position.add(particle.velocity);
            particle.life -= delta * 0.5;
            if (i < dustParticleCount) {
                dustPositions[i * 3] = particle.position.x;
                dustPositions[i * 3 + 1] = particle.position.y;
                dustPositions[i * 3 + 2] = particle.position.z;
                dustSizes[i] = particle.size * particle.life;
            }
        }
        for (let i = activeParticles.length - 1; i >= 0; i--) {
            if (activeParticles[i].life <= 0) {
                activeParticles.splice(i, 1);
            }
        }
        for (let i = activeParticles.length; i < dustParticleCount; i++) {
            dustPositions[i * 3] = 0;
            dustPositions[i * 3 + 1] = 0;
            dustPositions[i * 3 + 2] = 0;
            dustSizes[i] = 0;
        }
        dustParticles.attributes.position.needsUpdate = true;
        dustParticles.attributes.size.needsUpdate = true;
    };
    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        if (controls.accelerate) {
            speed = Math.min(maxSpeed, speed + acceleration);
        } else if (controls.brake) {
            if (speed > 0) {
                speed = Math.max(0, speed - brakingForce);
            } else {
                speed = Math.max(-maxReverseSpeed, speed - reverseAcceleration);
            }
        } else {
            if (speed > 0) {
                speed = Math.max(0, speed * friction);
            } else if (speed < 0) {
                speed = Math.min(0, speed * friction);
            }
            if (Math.abs(speed) < 0.005) speed = 0;
        }
        let steerDirection = 0;
        if (controls.steerLeft) steerDirection = 1;
        if (controls.steerRight) steerDirection = -1;
        const steerAdjust = speed !== 0 ? Math.max(0.15, 1 - Math.abs(speed / maxSpeed) * 0.75) : 1;
        const turnRate = steeringSpeed * steerDirection * steerAdjust;
        if (speed !== 0) {
            car.rotation.y += turnRate;
            const targetTilt = -steerDirection * Math.abs(speed) * 0.15;
            carBody.rotation.z = THREE.MathUtils.lerp(carBody.rotation.z, targetTilt, 0.1);
        } else {
            carBody.rotation.z = THREE.MathUtils.lerp(carBody.rotation.z, 0, 0.1);
        }
        // Calculate new position
        const newX = car.position.x + Math.sin(car.rotation.y) * speed;
        const newZ = car.position.z + Math.cos(car.rotation.y) * speed;
        
        // Boundary detection and collision response
        const boundaryMargin = 0; // Margin to keep car within the visible 600x600 walls
        const maxX = groundSize/2 - boundaryMargin;
        const maxZ = groundSize/2 - boundaryMargin;
        const minX = -groundSize/2 + boundaryMargin;
        const minZ = -groundSize/2 + boundaryMargin;
        
        // Check X boundary
        if (newX > maxX || newX < minX) {
            // Hit X boundary - stop forward movement and add slight bounce
            if (speed > 0) {
                speed *= 0.3; // Reduce speed significantly
            }
            // Keep car within bounds
            car.position.x = Math.max(minX, Math.min(maxX, car.position.x));
        } else {
            car.position.x = newX;
        }
        
        // Check Z boundary
        if (newZ > maxZ || newZ < minZ) {
            // Hit Z boundary - stop forward movement and add slight bounce
            if (speed > 0) {
                speed *= 0.3; // Reduce speed significantly
            }
            // Keep car within bounds
            car.position.z = Math.max(minZ, Math.min(maxZ, car.position.z));
        } else {
            car.position.z = newZ;
        }
        wheels.forEach(wheel => {
            wheel.rotation.x -= speed * wheelRotationSpeed;
            wheelRims.forEach(rim => {
                rim.rotation.x = wheel.rotation.x;
            });
        });
        trainAngle += trainSpeed;
        train.position.x = trackRadius * Math.cos(trainAngle);
        train.position.z = trackRadius * Math.sin(trainAngle);
        const lookAtX = trackRadius * Math.cos(trainAngle + 0.01);
        const lookAtZ = trackRadius * Math.sin(trainAngle + 0.01);
        train.lookAt(lookAtX, train.position.y, lookAtZ);
        clouds.forEach(cloud => {
            cloud.position.x -= cloud.userData.speed;
            if (cloud.position.x < -groundSize/2 - 100) {
                cloud.position.x = groundSize/2 + 100;
                cloud.position.z = (Math.random() - 0.5) * groundSize;
            }
        });
        const relativeCameraOffset = cameraOffset.clone().applyQuaternion(car.quaternion);
        const targetCameraPosition = car.position.clone().add(relativeCameraOffset);
        camera.position.lerp(targetCameraPosition, 0.085);
        camera.lookAt(car.position.x, car.position.y + 1.0, car.position.z);
        updateDustParticles(delta);
        updateSpeedometer();
        renderer.render(scene, camera);
    }
    animate();
</script>